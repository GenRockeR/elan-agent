server nac {
  listen {
    type = auth
    ipaddr = *
    port = 0
  }
  listen {
    type = auth
    ipv6addr = ::
    port = 0
  }
  
  listen {
    ipaddr = *
    port = 0
    type = acct
  }
  listen {
    ipv6addr = ::
    port = 0
    type = acct
  }
  
% if default_secret:
  client allv4 {
    ipaddr = 0.0.0.0
    netmask = 0
    secret = ${default_secret}
  }
  client allv6 {
    ipv6addr = ::
    netmask = 0
    secret = ${default_secret}
  }
% endif
  
  authorize {
    preprocess
    nac-eap {
      ok = return
    }

    if ( ( ! EAP-Message || EAP-TYPE == MD5 ) \
      && Calling-Station-Id \
      && User-Name =~ /^([0-9a-f]{1,2})[.:-]?([0-9a-f]{1,2})[.:-]?([0-9a-f]{1,2})[.:-]?([0-9a-f]{1,2})[.:-]?([0-9a-f]{1,2})[.:-]?([0-9a-f]{1,2})$/i ) {
        # Check Username Looks like Calling-station-ID
        if ( "%{Calling-Station-Id}" =~ /^(%{1})[.:-]?(%{2})[.:-]?(%{3})[.:-]?(%{4})[.:-]?(%{5})[.:-]?(%{6})/i ) {
            # Looks like Mac Auth
            update control {
                ClearText-Password := "%{User-Name}"
            }
            update reply {
                Origin-MAC := "%{tolower:%{1}:%{2}:%{3}:%{4}:%{5}:%{6}}"
            }
            # TODO: can we use NAS-Port-Type info ? : if( NAS-Port-Type == Wireless-802.11 || NAS-Port-Type == Wireless-Other ) {
        }
        if ( ! EAP-Message ) {
          chap
          pap
        }
    }
    elsif( EAP-TYPE == MD5 ) {
        update request {
            &Origin-Auth-Provider := "${dot1x_authentication}"
        }
        authentications
    }
  }
  
  authenticate {
    Auth-Type PAP {
      pap
    }
    Auth-Type CHAP {
      chap
    }
    Auth-Type MS-CHAP {
      mschap
    }
  
    nac-eap
  }
  
  
  preacct {
    preprocess
  
    #
    #  Merge Acct-[Input|Output]-Gigawords and Acct-[Input-Output]-Octets
    #  into a single 64bit counter Acct-[Input|Output]-Octets64.
    #
    acct_counters64
  
  
    update request {
        FreeRADIUS-Acct-Session-Start-Time = "%{expr: %l - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
    }
  
    acct_unique
  
  # ntdomain
  }
  
  accounting {
  #  -sql
  # sql_log
  # TODO: acct interim: seen mac + port if found...
  # TODO: acct stop: end Mac
  
    attr_filter.accounting_response
  
  # Acct-Type Status-Server {
  #
  # }
  }
  
  
  session {
  }
  
  
  post-auth {
  
    if( reply:Origin-MAC) {
      update request {
          &Origin-Auth-Type := "mac"
          &Origin-MAC := &reply:Origin-MAC
      }
    }
    else {
      update request {
          &Origin-Auth-Provider := "%{%{reply:Origin-Auth-Provider}:-${dot1x_authentication}}"
          &Origin-Login         := &reply:Origin-Login
          &Origin-Auth-Type     := "dot1x"
          &Origin-MAC           := &Calling-Station-ID
      }
    }

    update request {
      &Packet-Src-IP-Address   := "%{Packet-Src-IP-Address}"
      # TODO: Fix That  &Packet-Src-IPv6-Address := "%{Packet-Src-IPv6-Address}"
    }
    
    get-assignments
    
    
    if( &reply:Origin-VLAN-ID ) {
      update reply {
        Tunnel-Type := VLAN
        Tunnel-Medium-Type := IEEE-802
        Tunnel-Private-Group-Id := &reply:Origin-VLAN-ID
        Extreme-Netlogin-Vlan   := &reply:Origin-VLAN-ID
      }
    }

    
    #  MacSEC requires the use of EAP-Key-Name.  However, we don't
    #  want to send it for all EAP sessions.  Therefore, the EAP
    #  modules put required data into the EAP-Session-Id attribute.
    #  This attribute is never put into a request or reply packet.
    #
    #  Uncomment the next few lines to copy the required data into
    #  the EAP-Key-Name attribute
    # if (reply:EAP-Session-Id) {
    #   update reply {
    #     EAP-Key-Name := "%{reply:EAP-Session-Id}"
    #   }
    # }
  
    remove_reply_message_if_eap
  
    Post-Auth-Type REJECT {
      attr_filter.access_reject
  
      nac-eap
      
      seen
  
      remove_reply_message_if_eap
    }
  }
  
  pre-proxy {
  }
  
  post-proxy {
    nac-eap
  # Post-Proxy-Type Fail {
  #     detail
  # }
  }
}


server inner-eap-tunnel {
  authorize {
  
    chap
  
    mschap
  
    update control {
           Proxy-To-Realm := LOCAL
    }
  
    nac-eap {
      ok = return
    }
  
    expiration
    logintime
  
    update request {
        &Origin-Auth-Provider := "${dot1x_authentication}"
    }
  
    authentications
    
    pap

    update reply {
        &Origin-Login := User-Name
    }

  }
  
  
  authenticate {
    Auth-Type PAP {
      pap
    }
  
    Auth-Type CHAP {
      chap
    }
  
  
    Auth-Type MS-CHAP {
      mschap
    }
  
    nac-eap
  }
  
  session {
  }
  
  
  post-auth {
    Post-Auth-Type REJECT {
      # log failed authentications in SQL, too.
      -sql
      attr_filter.access_reject
    }
  
  }
  
  pre-proxy {
  }
  
  post-proxy {
  # attr_filter.post-proxy
    nac-eap
  
  # Post-Proxy-Type Fail {
  #     detail
  # }
  }
} # inner-tunnel server block



