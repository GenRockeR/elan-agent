#!/usr/bin/env python

import pycurl
import json
import time
import origin.libnflog_cffi
from origin.tracker import Tracker

class ConnectionSynapse():
    """ Synapse is the interface to the Central Controller
        Calls can be synchronious (post()) or async (start_post, request_finished, get_result)
    """
    def __init__(self):
        self.multi = pycurl.CurlMulti()
        self.ongoing_request = False
        
        self.output = ""
        
        c = pycurl.Curl()
        c.setopt(pycurl.URL, "127.0.0.1:8000/connections/")
        c.setopt(pycurl.HTTPHEADER, [
                # TODO: Remove that token from somewhere as it will get added by synapse module
                "Authorization: Token 74d6623e97f758efcc3832cae0880bf3f4240d22f1818767fe7f2fb69a70ddf1a22ab163f07c957e36e45b12af5fbc08f311a81d506a68907528bfe9da238e84",
                "Content-Type: application/json",
                "Expect:", # Disable the 'Expect: 100-continue' default curl behavior with large bodies to post
         ])
        c.setopt(pycurl.WRITEFUNCTION, self.__output)
        c.setopt(pycurl.POST, 1)
        self.connection = c 
        
    def __output(self, data):
        self.output = data
        
    def post(self, data):
        ''' Synchronious POST '''
        self.output = ''

        c = self.connection
        c.setopt(pycurl.POSTFIELDS, json.dumps(data))
        c.perform()

        return ( c.getinfo(pycurl.HTTP_CODE), self.output )
    
    def start_post(self, data):
        ''' Synchronious POST '''
        self.output = ''
        self.ongoing_request = True

        c = self.connection
        c.setopt(pycurl.POSTFIELDS, json.dumps(data))
        
        m = self.multi
        m.add_handle(c)
        m.perform()
        
    def request_finished(self):
        ''' check if async request is finished
            If no ongoing requests, returns True
        '''
        if self.ongoing_request:
            return self.multi.select(0)
        return True
    
    def get_result(self):
        ''' retrieves the result of an async request. Will block until request finished.'''
        m = self.multi
        #Poll wait for result to be ready (see pycurl code examples: http://pycurl.sourceforge.net/doc/curlmultiobject.html)
        ret, num_handles = m.perform()
        while num_handles:
            ret = m.select(1.0)
            if ret == -1:
                continue # retry on timeout
            ret, num_handles = m.perform()

        c = self.connection
        if self.ongoing_request:
            m.remove_handle(c)
            self.ongoing_request = False
        
        return ( c.getinfo(pycurl.HTTP_CODE), self.output )
            

POST_EVERY_X_REQUESTS = 100
POST_EVERY_X_SECONDS = 300
 
last_post_time = time.time()
post_pool = []

synapse = ConnectionSynapse()
 
def notifyNewConnection(pkt):
    global POST_EVERY_X_REQUESTS, POST_EVERY_X_SECONDS
    global last_post_time, post_pool, synapse
    
    pkt['start_time'] = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
     
    post_pool.append(pkt)
     
    if len(post_pool) >= POST_EVERY_X_REQUESTS or POST_EVERY_X_SECONDS <= (time.time() - last_post_time):
        # check if last request finished
        if synapse.request_finished():
            # Check how last request went on
            http_code, result = synapse.get_result()
            if http_code != 201 and http_code != 0:
                # Todo: Raise alert back to CC
                print "Error ", http_code, ': ', result
             
            synapse.start_post(post_pool)
            post_pool = []
 
nflog = origin.libnflog_cffi.NFLOG().generator(0, extra_attrs=['msg_packet_hwhdr', 'prefix'], nlbufsiz=2**24, handle_overflows = False)
fd = next(nflog)
 
tracker = Tracker(new_connection_cb = notifyNewConnection)
 
for pkt, hwhdr, direction  in nflog:
    try:
        tracker.processPacket( hwhdr + pkt, direction )
        if tracker.lastEstablishedConnexionsCleanup < time.time() - 60 * 1: # every 1 mn
            tracker.cleanupEstablishedConnexions()
    except Exception as e:
        # TODO: notify error to central manager...
        print 'Exception: ', type(e), e
