#!/usr/bin/env python

import sys, subprocess, time, os, socket, fcntl, struct
from origin.neuron import Dendrite
from mako.template import Template

class AccessControlConfigurator(Dendrite):
    internalNIC = 'eth1'
    bridge = 'br0'
    
    def __init__(self):
        super().__init__('access-control')
        
        self.agent_path = None
        self.vlans_path = None
        
        self.active = None
        self.vlans = {} # vlans by Vlan-ID
        
        # Retrieve Agent ID...
        self.retrieve('agent/self')

    def answer_cb(self, path, conf):
        # subscribe to our conf updates
        cmd = ''
        if path == 'agent/self':
            self.agent_path = path.replace('/self', '/' + str(conf['id']), 1)
            self.subscribe(self.agent_path)
            # get vlans to configure them.
            self.vlans_path = self.agent_path + '/vlans'
            self.subscribe(self.vlans_path)

        elif self.agent_path and path == self.agent_path:
            # Only do something if access_control has changed....
            if conf['access_control'] != self.active:
                self.active = conf['access_control']
                for family in ['bridge', 'ip', 'ip6']:
                    if conf['access_control']:
                        # enable Access Control
                        cmd += "nft flush chain {family} origin global_ac;".format(family=family)
                    else:
                        # disable Access Control
                        cmd += "nft add rule {family} origin global_ac accept;".format(family=family)
        elif self.vlans_path and path == self.vlans_path:
            # conf if list of all VLANS -> when a Vlan is modified, all VLANs are sent
            new_vlans = {}
            for vlan in conf:
                new_vlans[ vlan['vlan_id'] ] = vlan
            
            # Make sure internalNIC is up
            cmd += 'ifconfig {nic} up;'.format(nic=self.internalNIC)
            
            # New VLANS
            # TODO: separate this and make it more efficient...
            for vlan_id in set(new_vlans.keys()) - set(self.vlans.keys()):
                nic = self.internalNIC
                if vlan_id:
                    cmd += 'vconfig add {nic} {vlan_id}; ifconfig {nic}.{vlan_id} up;'.format(nic=nic, vlan_id=vlan_id)
                    nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                cmd += 'brctl addif {bridge} {nic};'.format(bridge=self.bridge, nic=nic)
            
            # VLANs to delete
            for vlan_id in set(self.vlans.keys()) - set(new_vlans.keys()):
                nic = self.internalNIC
                if vlan_id:
                    nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                cmd += 'brctl delif {bridge} {nic};'.format(nic=nic, bridge=self.bridge) 
                if vlan_id:
                    cmd += 'ifconfig {nic} down; vconfig rem {nic};'.format(nic=nic)
                cmd += 'nft delete element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                cmd += 'nft delete element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)

            # Create FW rules accordingly
            ebt_file = '/tmp/ea-network-ebt-{id}' . format(id=os.getpid())
            
            cmd += 'ebtables -t nat --atomic-file {} --atomic-init;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip --ip-protocol udp --ip-destination-port 67 -j mark --set-mark 10067;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip --ip-protocol udp --ip-destination-port 53 -j mark --set-mark 10053;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip6 --ip6-protocol udp --ip6-destination-port 53 -j mark --set-mark 10053;'.format(ebt_file)
            
            ip = get_ip_address('br0')
            ip6 = '2a01:e34:ee2e:e2a0:76ea:3aff:fe80:5e1'
            
            with open('/tmp/ea-network-nft-{id}' . format(id=os.getpid()), 'w') as nft_file:
                nft_file.write('flush chain ip origin captive_portal\n')
                nft_file.write('flush chain ip6 origin captive_portal\n')

                nft_file.write('add rule ip origin captive_portal ip daddr != {ip} jump allowed_macs\n'.format(ip=ip))
                #nft_file.write('add rule ip6 origin captive_portal ip6 daddr != {ip6} jump allowed_macs\n'.format(ip=ip6))
                
                for family in ['bridge', 'ip', 'ip6']:
                    nft_file.write('flush chain {} origin allowed_macs\n'.format(family))

                for vlan_id in new_vlans:
                    nic = self.internalNIC
                    if vlan_id:
                        nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                        
                    for family in ['bridge', 'ip', 'ip6']:
                        cmd += "nft add set {family} origin a_v_{vlan} '{{type ether_addr;}}';".format(family=family, vlan=vlan_id) 
    
                    # configure Access Contol
                    if new_vlans[vlan_id]['access_control']:
                        cmd += 'nft add element bridge origin ac_ifs {{{nic}}};'.format(nic=nic)

                        nft_file.write('add rule bridge origin allowed_macs iif {nic} ether saddr @a_v_{vlan} accept\n'.format(nic=nic, vlan=vlan_id))
                        for family in ['ip', 'ip6']:
                            nft_file.write('add rule {family} origin allowed_macs mark {vlan} ether saddr @a_v_{vlan} accept\n'.format(family=family, nic=nic, vlan=vlan_id))
                        
                        # configure captive portal if access control is enabled
                        if new_vlans[vlan_id]['web_authentication']:
                            cmd += 'ebtables -t nat --atomic-file {file} -A PREROUTING -i {nic} -j mark --mark-set {mark};'.format(file=ebt_file, nic=nic, mark=vlan_id)
                            nft_file.write('''add rule origin captive_portal tcp dport 80 mark {mark} dnat {ip}:{http}
add rule origin captive_portal tcp dport 443 mark {mark} dnat {ip}:{https}
'''.format(mark = vlan_id, http = vlan_id + 20000, https = vlan_id + 25000, ip = ip, ip6 = ip6 ))

                        # configure DHCP passthrough
                        if new_vlans[vlan_id]['dhcp_passthrough']:
                            cmd += 'nft add element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                        else:
                            cmd += 'nft delete element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                            
                        # configure DNS passthrough
                        if new_vlans[vlan_id]['dns_passthrough']:
                            cmd += 'nft add element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)
                        else:
                            cmd += 'nft delete element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)
    
                    else:
                        cmd += 'nft delete element bridge origin ac_ifs {{{nic}}};'.format(nic=nic)
                        
                cmd += 'nft -f {};'.format(nft_file.name)
                cmd += 'ebtables -t nat --atomic-file {} --atomic-commit;'.format(ebt_file)
                            
            # Set captive portals
            nginx_captive_portals = Template(filename = '/origin/network/nginx/server')
            with open("/etc/nginx/sites-enabled/captive-portal", "w") as nginx_file:
                nginx_file.write(nginx_captive_portals.render(vlans=new_vlans))
            cmd += 'reload nginx;'
            
            self.vlans = new_vlans

        if cmd:
            subprocess.call(cmd, shell=True)

# Temp Hack
def get_ip_address(ifname):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(fcntl.ioctl(
        s.fileno(),
        0x8915,  # SIOCGIFADDR
        struct.pack('256s', ifname[:15])
    )[20:24])

if __name__ == "__main__":
    conf = AccessControlConfigurator()
    count = 1
    while count < 100:
        conf.run_for_ever()
        time.sleep(30)
        count = count + 1
