#!/usr/bin/env python3

import subprocess, time, os
from origin.neuron import Dendrite
from origin.utils import get_ip4_address, get_ip6_address
from mako.template import Template

STATUS_IP = '8.8.8.8'
STATUS_IP6 = '2001:41d0:2:ba47::1000:1000'

class AccessControlConfigurator(Dendrite):
    internalNIC = 'eth1'
    bridge = 'br0'
    
    def __init__(self):
        super().__init__('access-control')
        
        self.agent_path = None
        self.vlans_path = None
        
        self.active = None
        self.vlans = {} # vlans by Vlan-ID
        
        if not self.is_registered():            
            # Retrieve Agent ID... once registered
            self.retrieve('agent/self')
            # DEFAULT CONF
            self.vlans[0] = {'access_control': False} # just so that once registered, this knows it has untagged vlan configured
            cmd = 'brctl addif {bridge} {nic};'.format(bridge=self.bridge, nic=self.internalNIC)
            subprocess.call(cmd, shell=True)
        else:
            self._init_subscriptions()
            
    def _init_subscriptions(self):
        self.agent_path = 'agent/' + self.synapse.get('agent:id')
        self.subscribe(self.agent_path)
        # get vlans to configure them.
        self.vlans_path = self.agent_path + '/vlans'
        self.subscribe(self.vlans_path)

    def answer_cb(self, path, conf):
        # subscribe to our conf updates
        cmd = ''
        if path == 'agent/self':
            self._init_subscriptions()

        elif self.agent_path and path == self.agent_path:
            # Only do something if access_control has changed....
            if conf['access_control'] != self.active:
                self.active = conf['access_control']
                for family in ['bridge', 'ip', 'ip6']:
                    if conf['access_control']:
                        # enable Access Control
                        cmd += "nft flush chain {family} origin global_ac;".format(family=family)
                    else:
                        # disable Access Control
                        cmd += "nft add rule {family} origin global_ac accept;".format(family=family)
        elif self.vlans_path and path == self.vlans_path:
            # conf if list of all VLANS -> when a Vlan is modified, all VLANs are sent
            new_vlans = {}
            for vlan in conf:
                new_vlans[ vlan['vlan_id'] ] = vlan
            
            # Make sure internalNIC is up
            cmd += 'ifconfig {nic} up;'.format(nic=self.internalNIC)
            
            # New VLANS
            # TODO: separate this and make it more efficient...
            for vlan_id in set(new_vlans.keys()) - set(self.vlans.keys()):
                nic = self.internalNIC
                if vlan_id:
                    cmd += 'vconfig add {nic} {vlan_id}; ifconfig {nic}.{vlan_id} up;'.format(nic=nic, vlan_id=vlan_id)
                    nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                cmd += 'brctl addif {bridge} {nic};'.format(bridge=self.bridge, nic=nic)
            
            # VLANs to delete
            for vlan_id in set(self.vlans.keys()) - set(new_vlans.keys()):
                nic = self.internalNIC
                if vlan_id:
                    nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                cmd += 'brctl delif {bridge} {nic};'.format(nic=nic, bridge=self.bridge) 
                if vlan_id:
                    cmd += 'ifconfig {nic} down; vconfig rem {nic};'.format(nic=nic)
                cmd += 'nft delete element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                cmd += 'nft delete element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)

            # Create FW rules accordingly
            ebt_file = '/tmp/ea-network-ebt-{id}' . format(id=os.getpid())
            
            cmd += 'ebtables -t nat --atomic-file {} --atomic-init;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip --ip-protocol udp --ip-source-port 68 --ip-destination-port 67 -j mark --set-mark 10067;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip6 --ip6-source fe80::0/10 --ip6-destination ff02::1:2 --ip6-protocol udp --ip6-source-port 546 --ip6-destination-port 547 -j mark --set-mark 10067;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip6 --ip6-protocol ipv6-icmp --ip6-icmp-type router-solicitation -j mark --set-mark 10067;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip --ip-protocol udp --ip-destination-port 53 -j mark --set-mark 10053;'.format(ebt_file)
            cmd += 'ebtables -t nat --atomic-file {} -A PREROUTING --protocol ip6 --ip6-protocol udp --ip6-destination-port 53 -j mark --set-mark 10053;'.format(ebt_file)
           
            ip = get_ip4_address('br0')
            ip6 = get_ip6_address('br0')
            
            with open('/tmp/ea-network-nft-{id}' . format(id=os.getpid()), 'w') as nft_file:
                nft_file.write('flush chain ip origin captive_portal\n')
                nft_file.write('flush chain ip6 origin captive_portal\n')
                
                # Agent Status
                nft_file.write('add rule ip  origin captive_portal ip  daddr {status_ip} dnat {ip}\n'.format(ip=ip, status_ip=STATUS_IP))
                nft_file.write('add rule ip6 origin captive_portal ip6 daddr {status_ip} dnat {ip}\n'.format(ip=ip6, status_ip=STATUS_IP6))

                nft_file.write('add rule ip  origin captive_portal ip  daddr != {ip}  jump allowed_macs\n'.format(ip=ip))
                nft_file.write('add rule ip6 origin captive_portal ip6 daddr != {ip} jump allowed_macs\n'.format(ip=ip6))
                
                for family in ['bridge', 'ip', 'ip6']:
                    nft_file.write('flush chain {} origin allowed_macs\n'.format(family))

                for vlan_id in new_vlans:
                    nic = self.internalNIC
                    if vlan_id:
                        nic = '{nic}.{vlan_id}'.format(nic=nic, vlan_id=vlan_id)
                        
                    for family in ['bridge', 'ip', 'ip6']:
                        cmd += "nft add set {family} origin a_v_{vlan} '{{type ether_addr;}}';".format(family=family, vlan=vlan_id) 
    
                    # configure Access Contol
                    if new_vlans[vlan_id]['access_control']:
                        cmd += 'nft add element bridge origin ac_ifs {{{nic}}};'.format(nic=nic)

                        nft_file.write('add rule bridge origin allowed_macs iif {nic} ether saddr @a_v_{vlan} accept\n'.format(nic=nic, vlan=vlan_id))
                        for family in ['ip', 'ip6']:
                            nft_file.write('add rule {family} origin allowed_macs mark {mark} ether saddr @a_v_{vlan} accept\n'.format(family=family, nic=nic, vlan=vlan_id, mark=vlan_id+1000))
                        
                        # configure captive portal if access control is enabled
                        if new_vlans[vlan_id]['web_authentication'] or new_vlans[vlan_id]['guest_access']:
                            cmd += 'ebtables -t nat --atomic-file {file} -A PREROUTING -i {nic} -j mark --mark-set {mark};'.format(file=ebt_file, nic=nic, mark=vlan_id+1000)
                            nft_file.write('''add rule origin captive_portal tcp dport 80 mark {mark} dnat {ip}:{http}
add rule origin captive_portal tcp dport 443 mark {mark} dnat {ip}:{https}
add rule ip6 origin captive_portal tcp dport 80 mark {mark} dnat {ip6}:{http}
add rule ip6 origin captive_portal tcp dport 443 mark {mark} dnat {ip6}:{https}
'''.format(mark = vlan_id+1000, http = vlan_id + 20000, https = vlan_id + 25000, ip = ip, ip6 = ip6 ))

                        # configure DHCP passthrough
                        if new_vlans[vlan_id]['dhcp_passthrough']:
                            cmd += 'nft add element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                        else:
                            cmd += 'nft delete element bridge origin dhcp_pt_ifs {{{nic}}};'.format(nic=nic)
                            
                        # configure DNS passthrough
                        if new_vlans[vlan_id]['dns_passthrough']:
                            cmd += 'nft add element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)
                        else:
                            cmd += 'nft delete element bridge origin dns_pt_ifs {{{nic}}};'.format(nic=nic)
    
                    else:
                        cmd += 'nft delete element bridge origin ac_ifs {{{nic}}};'.format(nic=nic)
                        
                cmd += 'nft -f {};'.format(nft_file.name)
                cmd += 'ebtables -t nat --atomic-file {} --atomic-commit;'.format(ebt_file)
                            
            # Set captive portals
            nginx_captive_portals = Template(filename = '/origin/network/nginx/server')
            with open("/etc/nginx/sites-enabled/captive-portal", "w") as nginx_file:
                nginx_file.write(nginx_captive_portals.render(vlans=new_vlans))
            cmd += 'reload nginx;'
            
            self.vlans = new_vlans

        if cmd:
            subprocess.call(cmd, shell=True)


if __name__ == "__main__":
    conf = AccessControlConfigurator()
    count = 1
    while count < 100:
        conf.run_for_ever()
        time.sleep(30)
        count = count + 1
